# csi-vae with PyTorch

This repository contains a modified version of the original csi-vae project, which was initially developed in TensorFlow. The main changes introduced include:

**Migration to PyTorch :**
The code has been completely rewritten in PyTorch, preserving the original model's architecture and logic while taking advantage of PyTorch's flexibility and modularity.

**Increased Flexibility :**
Dynamic antenna selection: It is now possible to select one, multiple specific, or all available antennas as input to the model through a simple configuration setting.

Configurable activation functions: Users can easily choose the type of activation function (ReLU, LeakyReLU, ELU, etc.) to use in the model by leveraging the torch.nn modules.

**Configuration via JSON5 :**
Model and training parameters are now managed through a config.json5 file, which allows comments and greater flexibility when defining parameters. This makes tuning and using the code much simpler and more readable.

**Secure Saving with SafeTensor :**
Trained models are saved using SafeTensor, a secure and efficient format for tensor serialization.


## Useful links

- [Raw CSI dataset](https://doi.org/10.5281/zenodo.7732595)


#  Neuro-Symbolic Causal Analysis of VAE Latent Spaces

This part of project explores the application of temporal causal discovery and symbolic rule extraction on the latent spaces generated in the first part.
The primary objective is to move from a sub-symbolic representation (the latent vectors) to an interpretable, symbolic representation (Linear Temporal Logic - LTL formulas) that describes the behavior of different human activities.

The workflow is divided into two main phases:
1.  **Causal Discovery:** Using the `Tigramite` library to analyze the time series of the latent spaces and generate causal graphs that reveal the interdependencies between the abstract features.
2.  **LTL Rule Extraction:** Employing a machine learning approach (a Decision Tree) to automatically extract the distinctive "causal fingerprints" of each activity and translate them into formal LTL rules.

---
## Prerequisites

* **Python 3.x** and an environment like Jupyter Notebook.
* **Dataset:** The `.safetensors` files containing the latent spaces generated by the VAEs must be located in the `../dataset/` directory.
* **Python Libraries:** Run the following command to install the necessary dependencies with their specific versions to ensure compatibility.

    ```bash
    pip install tigramite==5.2.5.8 numba==0.58.1 numpy==1.26.4 llvmlite==0.41.1 scikit-learn pandas
    ```

---
## Workflow and Script Descriptions

The complete process involves running an analysis script (Phase 1) to generate numerical results, followed by the rule extraction script (Phase 2).

### Phase 1: Causal Analysis Scripts

These scripts take the latent space data as input and produce causal graphs and a `.pkl` results file. Choose the script based on the data you wish to analyze.

#### `CSI-VAE_Causal_Analysis_Gaussian_ParCorr.ipynb`
* **Purpose:** To analyze the **continuous** latent space generated by the Gaussian VAE.
* **Method:** Uses the `ParCorr` (Partial Correlation) independence test, which is suitable for investigating linear relationships between the 8 continuous features of the latent space.
* **Output:** Causal graphs and an `all_causal_results_parcorr.pkl` file.

#### `CSI-VAE_Causal_Analysis_Gumbel_ParCorr.ipynb`
* **Purpose:** An experimental approach to analyze the Gumbel data with a test for continuous data, as suggested by the professor.
* **Method:** Transforms the one-hot vector into a **single pseudo-continuous variable** (by converting its index to a float) and then applies the `ParCorr` test to analyze its auto-causality over time.
* **Output:** Causal graphs and an `all_causal_results_gumbel_parcorr.pkl` file.

---
### Phase 2: LTL Rule Mining Script

This script takes the `.pkl` file generated in Phase 1 as input and produces the final rules.

#### `CSI-VAE_LTL_Rule_Mining.ipynb`
* **Purpose:** To automate the discovery of "causal fingerprints" and translate them into LTL formulas.
* **Input:** A results file, for example `all_causal_results_parcorr.pkl`.
* **Method:**
    1.  Loads the results and filters for **stable** causal links (those consistent across different random seeds).
    2.  Creates a "dataset of graphs" where each activity is described by the presence/absence of these stable links.
    3.  Trains a **Decision Tree** to find the most discriminative combinations of links.
    4.  Extracts the `if-then` rules from the tree and **automatically translates them into LTL formulas**.
* **Output:** A folder structure in `../result/ltl_rules/` containing a `.txt` file with the LTL rule for each activity and for each `window_size`.

---
## How to Run the Full Pipeline

1.  Ensure all prerequisites are met and the `.safetensors` data files are in place.
2.  **Run one of the Phase 1 analysis scripts** (e.g., `CSI-VAE_Causal_Analysis_Gaussian_ParCorr.ipynb`). This will generate the necessary `.pkl` results file and the causal graphs.
3.  **Open and run the Phase 2 script** (`CSI-VAE_LTL_Rule_Mining.ipynb`).
4.  Check the `../result/ltl_rules/` directory to find the generated text files with the LTL formulas.


